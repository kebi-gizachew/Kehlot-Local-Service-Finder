<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kehlot Unified Chat System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --kehlot-teal: #0F98B3;
            --user-bubble: #E9E9EB;
            --text-dark: #1F2937;
            --bg-light: #F8FAFC;
        }

        body, html { height: 100%; margin: 0; font-family: 'Inter', sans-serif; background: #F0F2F5; overflow: hidden; }

        .app-shell { display: flex; align-items: center; justify-content: center; height: 100vh; padding: 20px; box-sizing: border-box; }
        .chat-container { 
            width: 100%; max-width: 500px; height: 100%; background: white; 
            display: flex; flex-direction: column; border-radius: 16px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); overflow: hidden;
        }

        .chat-header { padding: 15px 20px; background: var(--kehlot-teal); color: white; display: flex; align-items: center; gap: 12px; flex-shrink: 0; }
        
        .avatar-circle { 
            width: 40px; height: 40px; border-radius: 50%; background: rgba(255,255,255,0.2);
            display: flex; align-items: center; justify-content: center; font-weight: 700;
            overflow: hidden; border: 1px solid rgba(255,255,255,0.3); flex-shrink: 0;
            text-transform: uppercase; font-size: 16px;
        }
        .avatar-circle img { width: 100%; height: 100%; object-fit: cover; }

        .chat-body { flex: 1; padding: 20px; overflow-y: auto; overflow-x: hidden; display: flex; flex-direction: column; gap: 12px; background: var(--bg-light); }
        .message { max-width: 80%; display: flex; flex-direction: column; position: relative; cursor: pointer; -webkit-tap-highlight-color: transparent; }
        .message.sent { align-self: flex-end; }
        .message.received { align-self: flex-start; }

        .bubble { 
            padding: 10px 14px; border-radius: 18px; font-size: 14.5px; line-height: 1.5; 
            word-wrap: break-word; overflow-wrap: break-word; white-space: pre-wrap;
        }
        .sent .bubble { background: var(--kehlot-teal); color: white; border-bottom-right-radius: 4px; }
        .received .bubble { background: var(--user-bubble); color: var(--text-dark); border-bottom-left-radius: 4px; }

        .message .bubble.image-bubble {
            background: rgba(15, 152, 179, 0.14) !important; 
            border: 1px solid rgba(15, 152, 179, 0.22);
            padding: 6px;
            border-radius: 12px;
            display: inline-block;
        }

        .img-container { width: 220px; height: 220px; border-radius: 10px; overflow: hidden; background: white; }
        .msg-image { width: 100%; height: 100%; object-fit: cover; display: block; }

        .chat-footer { padding: 15px; border-top: 1px solid #EEE; display: flex; gap: 12px; align-items: center; background: white; }
        .chat-input { flex: 1; padding: 10px 15px; border-radius: 20px; border: none; background: #F1F3F4; outline: none; font-size: 14px; }
        .footer-btn { background: none; border: none; color: var(--kehlot-teal); cursor: pointer; font-size: 1.3rem; transition: 0.2s; }
        .footer-btn:hover { opacity: 0.8; }

        #msg-menu { position: fixed; background: white; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); display: none; z-index: 1000; min-width: 130px; }
        .menu-item { padding: 12px 16px; font-size: 14px; cursor: pointer; display: flex; align-items: center; gap: 8px; }
        #full-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: none; justify-content: center; align-items: center; z-index: 2000; }
    </style>
</head>
<body>

<div class="app-shell">
    <div class="chat-container">
        <header class="chat-header">
            <div id="header-avatar-slot"></div>
            <div class="header-info">
                <div id="header-name" style="font-weight: 600;">Recipient Name</div>
            </div>
        </header>

        <div id="chat-messages" class="chat-body"></div>

        <footer class="chat-footer">
            <button class="footer-btn" onclick="document.getElementById('fIn').click()">
                <i class="fa-solid fa-paperclip"></i>
            </button>
            <input type="file" id="fIn" style="display:none" accept="image/jpeg,image/png,image/webp" onchange="ChatApp.handleUpload(event)">
            
            <input type="text" id="msg-input" class="chat-input" placeholder="Message..." onkeypress="if(event.key==='Enter') ChatApp.sendMessage()">
            
            <button class="footer-btn" id="send-btn" onclick="ChatApp.sendMessage()">
                <i class="fa-solid fa-paper-plane"></i>
            </button>
        </footer>
    </div>
</div>

<div id="msg-menu">
    <div id="view-opt" class="menu-item" onclick="ChatApp.viewImage()"><i class="fa-regular fa-eye"></i> View</div>
    <div class="menu-item" style="color:#EF4444;" onclick="ChatApp.deleteMessage()"><i class="fa-regular fa-trash-can"></i> Delete</div>
</div>

<div id="full-overlay" onclick="this.style.display='none'"><img id="overlay-img" src="" style="max-width:90%; max-height:90%;"></div>

<script>
/**
 * 1. NETWORK LAYER (MOCKED)
 */
const Network = {
    async pushMessage(payload) {
        await new Promise(res => setTimeout(res, 500));
        if (Math.random() < 0.05) throw new Error("Sync Failed");
        return { ...payload, messageId: 'msg_' + Date.now(), status: 'sent' };
    },
    async deleteMessage(messageId) {
        await new Promise(res => setTimeout(res, 300));
        return true;
    },
    async fetchMessages(conversationId) {
        await new Promise(res => setTimeout(res, 200));
        // Mock: return some messages
        return [
            { messageId: 'msg1', senderId: this.currentUser.userId, content: "Hello!", type: 'text', timestamp: new Date(Date.now() - 60000).toISOString() },
            { messageId: 'msg2', senderId: this.recipient.userId, content: "Hi there!", type: 'text', timestamp: new Date(Date.now() - 30000).toISOString() }
        ];
    },
    async pollNewMessages(lastMessageId) {
        await new Promise(res => setTimeout(res, 1000));
        // Mock: occasionally return a new message
        if (Math.random() < 0.3) {
            return { messageId: 'msg' + Date.now(), senderId: this.recipient.userId, content: "New message from provider!", type: 'text', timestamp: new Date().toISOString() };
        }
        return null;
    }
};

/**
 * 2. CHAT APP LOGIC
 */
const ChatApp = {
    currentUser: { userId: 1, role: "user", name: "Seeker", profileImage: "" },
    recipient: { userId: 2, role: "provider", name: "Provider", profileImage: "" },
    activeMsg: null,
    isProcessing: false,
    lastMessageId: null,
    pollingInterval: null,

    init() {
        // Get providerId from URL
        const urlParams = new URLSearchParams(window.location.search);
        const providerId = urlParams.get('providerId');
        if (providerId) {
            this.recipient.userId = providerId;
            this.recipient.name = "Provider " + providerId; // Mock name
        }

        document.getElementById('header-avatar-slot').innerHTML = this.getAvatarMarkup(this.recipient);
        document.getElementById('header-name').textContent = this.recipient.name;
        
        // Load conversation history
        this.loadMessages();

        // Start polling for new messages
        this.startPolling();
    },

    getAvatarMarkup(user) {
        if (user.role === 'provider' && user.profileImage) {
            return `<div class="avatar-circle"><img src="${user.profileImage}" alt="${user.name}"></div>`;
        }
        return `<div class="avatar-circle">${user.name.charAt(0)}</div>`;
    },

    async loadMessages() {
        try {
            const messages = await Network.fetchMessages(this.recipient.userId);
            messages.forEach(msg => {
                const direction = msg.senderId === this.currentUser.userId ? 'sent' : 'received';
                const el = this.renderMessage(msg, direction);
                if (msg.messageId) el.dataset.messageId = msg.messageId;
            });
            if (messages.length > 0) {
                this.lastMessageId = messages[messages.length - 1].messageId;
            }
        } catch (err) {
            console.error("Failed to load messages:", err);
        }
    },

    startPolling() {
        this.pollingInterval = setInterval(async () => {
            try {
                const newMsg = await Network.pollNewMessages(this.lastMessageId);
                if (newMsg) {
                    const el = this.renderMessage(newMsg, 'received');
                    el.dataset.messageId = newMsg.messageId;
                    this.lastMessageId = newMsg.messageId;
                }
            } catch (err) {
                console.error("Polling error:", err);
            }
        }, 3000); // Poll every 3 seconds
    },

    // --- UPLOAD & SEND ---

    async handleUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        // Strict Validation
        const allowed = ['image/jpeg', 'image/png', 'image/webp'];
        if (!allowed.includes(file.type)) return alert("Format not supported.");
        if (file.size > 5 * 1024 * 1024) return alert("Max size 5MB.");

        const reader = new FileReader();
        reader.onload = (f) => this.initiateMessage(f.target.result, "image");
        reader.readAsDataURL(file);
        e.target.value = ""; 
    },

    async sendMessage() {
        if (this.isProcessing) return;
        const input = document.getElementById('msg-input');
        const text = input.value.trim();
        if (!text) return;
        
        input.value = '';
        await this.initiateMessage(text, "text");
    },

    async initiateMessage(content, type) {
        this.isProcessing = true;
        const payload = {
            senderId: this.currentUser.userId,
            receiverId: this.recipient.userId,
            type: type,
            content: content,
            timestamp: new Date().toISOString()
        };

        try {
            const el = this.renderMessage(payload, "sent");
            const response = await Network.pushMessage(payload);
            el.dataset.messageId = response.messageId;
            this.lastMessageId = response.messageId;
            console.log("Success: Message pushed to backend.");
        } catch (err) {
            console.error("Backend Error:", err.message);
        } finally {
            this.isProcessing = false;
        }
    },

    // --- RENDERING (Original Styling Restored) ---

    renderMessage(msgData, direction) {
        const viewport = document.getElementById('chat-messages');
        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${direction}`;
        
        msgDiv.oncontextmenu = (e) => e.preventDefault();
        msgDiv.onclick = (e) => this.showMenu(e, msgData.type, msgDiv);

        const bubble = document.createElement('div');
        bubble.className = 'bubble';

        if (msgData.type === 'text') {
            bubble.textContent = msgData.content;
        } else {
            // RESTORED ORIGINAL IMAGE HOLDER STRUCTURE
            bubble.classList.add("image-bubble");
            bubble.innerHTML = `<div class="img-container"><img src="${msgData.content}" class="msg-image"></div>`;
        }

        msgDiv.appendChild(bubble);
        viewport.appendChild(msgDiv);
        viewport.scrollTo({ top: viewport.scrollHeight, behavior: 'smooth' });
        return msgDiv;
    },

    // --- MENU & ACTIONS ---

    showMenu(e, type, el) {
        e.stopPropagation();
        this.activeMsg = el;
        const menu = document.getElementById('msg-menu');
        const x = Math.min(e.clientX, window.innerWidth - 140);
        const y = Math.min(e.clientY, window.innerHeight - 100);

        menu.style.display = 'block';
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        document.getElementById('view-opt').style.display = (type === 'image') ? 'flex' : 'none';
    },

    async deleteMessage() { 
        if(!this.activeMsg || this.activeMsg.dataset.deleting === "true") return;
        
        const target = this.activeMsg;
        const mid = target.dataset.messageId || 'temp';

        try {
            target.dataset.deleting = "true";
            await Network.deleteMessage(mid);
            target.remove();
            console.log("Delete: Success.");
        } catch (err) {
            target.dataset.deleting = "false";
            console.error("Delete: Error.");
        } finally {
            this.hideMenu(); 
        }
    },

    viewImage() {
        if (!this.activeMsg) return;
        const img = this.activeMsg.querySelector('img').src;
        document.getElementById('overlay-img').src = img;
        document.getElementById('full-overlay').style.display = 'flex';
        this.hideMenu();
    },

    hideMenu() { document.getElementById('msg-menu').style.display = 'none'; this.activeMsg = null; }
};

window.onclick = () => ChatApp.hideMenu();
ChatApp.init();
</script>

</body>
</html>